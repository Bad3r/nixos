# RFC-001 (rev 3.6): App Module Composition (Helpers-First, Type-Correct)

Status (September 19, 2025): Revision drafted for acceptance. This update records the present repository state and the concrete work required before marking the RFC as accepted/implemented.

## Summary

- Adopt a shared helper surface (`flake.lib.nixos.getApp/getApps`) so role modules compose per-app modules consistently without re-implementing lookups.
- Continue exporting per-app modules under `flake.nixosModules.apps.<name>` (no registry inversion required for this revision).
- Preserve stable role aliases (`role-dev`, `role-media`, `role-net`) for host imports while tightening enforcement around their composition.
- Ship CI/pre-commit guardrails and documentation updates that codify these practices.

Process guard: Until this revision is formally accepted, no code is assumed to exist. The implementation steps below describe the exact work that must land alongside the acceptance PR.

## Motivation

Role modules still hand-roll the same `lib.hasAttrByPath` / `lib.getAttrFromPath` snippets to guard missing apps (`modules/roles/dev.nix`, `modules/roles/media.nix`, `modules/roles/net.nix`). The pattern works, but it spreads knowledge about lookup semantics and error handling across multiple call sites. The goal of this RFC is to concentrate those semantics in a single helper surface, tighten linting around it, and document the approach so future module authors have an obvious path.

The existing aggregator (`flake.nixosModules`) remains the canonical source of truth; this RFC intentionally avoids reading from `inputs.self.*` or introducing a new registry. Instead, it prepares the ground for potential future automation (including the registry exploration in `docs/RFC-single-source-of-truth-app-modules.md`) by ensuring today’s lookup behaviour is consistent and observable from one location.

## Goals

- Provide a shared helper API for role composition so app lookups and error handling remain consistent.
- Keep the per‑app module pattern self-contained under `flake.nixosModules.apps.<name>` while making it easier to consume.
- Preserve stable role aliases (`role-dev`, `role-media`, `role-net`) and ensure host imports remain declarative.
- Capture the helper usage in docs/CI so regressions are caught automatically.

## Current State (September 2025)

- Role modules implement lookup guards inline (see `modules/roles/dev.nix`, `modules/roles/media.nix`, `modules/roles/net.nix`) and expose alias modules, but no shared helper surface exists yet.
- `modules/meta/flake-output.nix` defines `flake.lib.meta` and `flake.lib.homeManager` namespaces only; there is no `flake.lib.nixos` option declared.
- The pre-commit hook set in `modules/meta/git-hooks.nix` lacks the `forbid-with-apps-in-roles` guard described by earlier revisions of this document.
- Documentation (including this RFC) still claims helpers/CI are in place, leading to drift between policy and implementation.

## Critical Analysis and Type Notes

- Aggregator contract: `flake.nixosModules` remains a freeform attrset populated by import-tree. By keeping helpers as readers over `config.flake.nixosModules`, we respect the existing contract and avoid re-shaping the output.
- Self recursion: The helper implementations operate exclusively on `config` (not on `inputs.self.*`), avoiding evaluation loops.
- Future-proofing: Centralising lookups now makes it easier to pursue the registry exploration later; the helper API can simply delegate to a registry if we adopt one.

## Helpers (Complete Solution)

File to add: `modules/meta/nixos-app-helpers.nix`

- Define configuration‑aware helpers over the current aggregator (no new registry):

```nix
{ lib, config, ... }:
{
  flake.lib.nixos = {
    hasApp = name: lib.hasAttrByPath [ "apps" name ] config.flake.nixosModules;

    getApp = name:
      if lib.hasAttrByPath [ "apps" name ] config.flake.nixosModules then
        lib.getAttrFromPath [ "apps" name ] config.flake.nixosModules
      else
        throw "Unknown NixOS app '${name}'";

    getApps = names: map (n: config.flake.lib.nixos.getApp n) names;

    getAppOr = name: default:
      if lib.hasAttrByPath [ "apps" name ] config.flake.nixosModules
      then lib.getAttrFromPath [ "apps" name ] config.flake.nixosModules
      else default;
  };
}
```

Helper availability: Since Nix modules merge options lazily, these helpers are available to roles at evaluation time regardless of import order.

Helpers contract: Helpers are pure/idempotent readers over `config` (functions + small metadata only) and MUST NOT perform heavy evaluation or side effects.

Helpers root option: Declare a helpers namespace to avoid unknown‑option warnings. Add in a meta module (MUST be declared upon implementation approval):

```nix
options.flake.lib.nixos = lib.mkOption {
  type = lib.types.attrsOf lib.types.anything;
  default = {};
  description = "Helper functions for NixOS app composition";
};
```

## App Module Authoring Pattern

- Keep existing pattern: per‑app modules export to `flake.nixosModules.apps.<name> = …`.
- Continue using functions when `pkgs`/args are needed, per repo style.

## Roles Composition via Helpers

Example: `modules/roles/dev.nix`

```nix
{ config, ... }:
let
  getApps = config.flake.lib.nixos.getApps;
in
{
  flake.nixosModules.roles.dev.imports =
    getApps [
      "neovim" "vim" "cmake" "gcc" "gnumake" "pkg-config"
      "jq" "yq" "jnv" "tokei" "hyperfine" "git-filter-repo"
      "exiftool" "niv" "tealdeer" "httpie" "mitmproxy"
      "gdb" "valgrind" "strace" "ltrace" "vscodeFhs" "kiroFhs"
    ]
    ++ [ config.flake.nixosModules.dev.node ];
}
```

Apply the same pattern to `roles/media.nix` and `roles/net.nix`, preserving non‑app imports (e.g., `"vpn-defaults"`, `media`).

Note on Node bundle (decision): Adopt the `config.flake.nixosModules.dev.node` bundle as the single source of truth in `roles/dev.nix` (to be executed upon approval). Add a short comment enumerating the bundle contents to guide future edits. (Migrations of existing code are out of scope for rev 3.6.)

### Examples (copy‑pasteable)

Minimal app authoring and role composition:

```nix
# modules/apps/neovim.nix
{ config, ... }:
{
  flake.nixosModules.apps.neovim = { pkgs, ... }: {
    environment.systemPackages = [ pkgs.neovim ];
  };
}

# modules/roles/dev.nix
{ config, ... }:
let
  getApps = config.flake.lib.nixos.getApps;
in
{
  flake.nixosModules.roles.dev.imports = getApps [ "neovim" ];
}
```

### Role Namespace

- Roles live under `flake.nixosModules.roles.<name>` (for example, `.dev`, `.media`, `.net`).
- Keep host imports declarative by referencing the role namespace instead of duplicating the underlying list.

Hosts import role modules for consistency:

```nix
(with config.flake.nixosModules; [
  workstation
  nvidia-gpu
]) ++ [
  config.flake.nixosModules.roles.dev
  config.flake.nixosModules.roles.media
  config.flake.nixosModules.roles.net
]
```

## Relationship to Registry Exploration

`docs/RFC-single-source-of-truth-app-modules.md` continues to track the optional registry inversion. Accepting this revision does not preclude that work; instead, it ensures current consumers rely on a single helper surface so any future registry can slot in behind the same API without another round of role edits.

## Alternatives Considered

1. `with config.flake.nixosModules.apps`

- Fragile with aggregator flattening; replaced by explicit helpers.

2. Building an index from `inputs.self.nixosModules.apps`

- Risks self recursion; not acceptable.

3. Full registry inversion under `flake.lib.nixos.*`

- Unnecessary for current goals; helpers over the existing aggregator deliver the benefits with less disruption and remain type‑correct.

## Implementation Plan (execution required for acceptance)

1. **Declare the helper namespace.** Extend `modules/meta/flake-output.nix` with a `flake.lib.nixos` option (attrsOf anything, default `{}`) so helper functions can merge without unknown-option warnings.
2. **Add the helper implementation.** Introduce `modules/meta/nixos-app-helpers.nix` exporting `flake.lib.nixos.{hasApp?,getApp,getApps,getAppOr}` exactly as specified in this RFC, including clear error messages when an app is missing.
3. **Refactor role modules.** Update `modules/roles/{dev,media,net}.nix` so they:
   - Call `config.flake.lib.nixos.getApps` for their app lists (no inline `lib.hasAttrByPath` / `lib.getAttrFromPath`).
   - Export their imports under `flake.nixosModules.roles.<name>` only (no legacy alias attributes).
   - Document non-app imports (e.g., VPN defaults) with short comments when appropriate.
4. **Install guardrails.**
   - Add a pre-commit hook (see below) that forbids `with config.flake.nixosModules.apps` within `modules/roles/**/*.nix`.
   - Add a CI assertion under `modules/meta/ci.nix` (or equivalent) that validates helper presence and role module lists during automated checks.
5. **Update documentation and examples.** Refresh `docs/RFC-001.md`, `docs/DENDRITIC_PATTERN_REFERENCE.md`, `docs/MODULE_STRUCTURE_GUIDE.md`, and `modules/readme.nix` snippets to reference the helper API instead of inline lookups. Note the relationship to the registry exploration in `docs/RFC-single-source-of-truth-app-modules.md`.
6. **Verification.** Run `nix fmt`, `nix develop -c pre-commit run --all-files`, `generation-manager score`, and `nix flake check --accept-flake-config` to demonstrate the checks pass with the new guardrails enabled. Include the command outputs (or summaries) in the acceptance PR description.

### Regression Guard: Pre-commit Hook (normative)

- Implement the hook inside `modules/meta/git-hooks.nix` alongside the existing `ensure-input-branches-pushed`, `statix`, etc., so developers inherit the guard when running `nix develop -c pre-commit run --all-files`.
- Environment: relies on `pkgs.ripgrep` with PCRE2 enabled; retains a `grep` fallback for environments without `rg` (documented as less precise).
- Hook details:

```nix
forbid-with-apps-in-roles =
  let
    checker = pkgs.writeShellApplication {
      name = "forbid-with-apps-in-roles";
      runtimeInputs = [ pkgs.ripgrep pkgs.gnugrep pkgs.coreutils ];
      text = ''
        set -euo pipefail
        cd "$(git rev-parse --show-toplevel)"
        if rg -nU --pcre2 --glob 'modules/roles/**/*.nix' -e '(?s)with\s*\(?\s*config\.flake\.nixosModules\.apps\s*\)?\s*;' >/dev/null; then
          echo "✗ Forbidden usage found in modules/roles/**/*.nix" >&2
          echo "  Use helpers: config.flake.lib.nixos.getApp/getApps (see docs/RFC-001.md)." >&2
          rg -nU --pcre2 --glob 'modules/roles/**/*.nix' -e '(?s)with\s*\(?\s*config\.flake\.nixosModules\.apps\s*\)?\s*;' || true
          exit 1
        fi
      '';
    };
  in
  {
    enable = true;
    name = "forbid-with-apps-in-roles";
    entry = lib.getExe checker;
    pass_filenames = false;
    always_run = true;
    verbose = true;
  };
```

- Scope: Only `modules/roles/**/*.nix` are checked; other namespaces (e.g., `dev`, `lang`) are not restricted by this rule.
- Guidance: Replace the forbidden construct with `config.flake.lib.nixos.getApps [ "app1" "app2" ]` (or `map getApp …`).
- CI tool: CI MUST use ripgrep with PCRE2; grep fallback is local only and less precise. Dev shell MUST include `pre-commit` and `rg` so `nix develop -c pre-commit run --all-files` performs the guard end‑to‑end.
  Note: The PCRE2 guard may match commented or quoted code in rare cases; this is acceptable noise to triage manually given the narrow scope.

### Cheap Smoke Check (Evaluation‑Only)

- Add flake‑level checks (placed in a meta CI module such as `modules/meta/ci.nix`) that assert:
  - Each core role (`roles.dev`, `roles.media`, `roles.net`) exists under `flake.nixosModules.roles`.
  - Each role’s `imports` evaluates to a list (no builds).
  - Helpers exist under `config.flake.lib.nixos` using attribute tests (e.g., `(config.flake.lib.nixos ? getApp) && (config.flake.lib.nixos ? getApps) && (config.flake.lib.nixos ? getAppOr) && (config.flake.lib.nixos ? hasApp)`).

Example (flake‑level module):

```nix
# modules/meta/ci.nix
{ lib, config, ... }:
{
  checks = {
    role-modules-exist = builtins.toFile "role-modules-exist-ok" (
      if (config.flake.nixosModules.roles ? dev)
        && (config.flake.nixosModules.roles ? media)
        && (config.flake.nixosModules.roles ? net)
      then "ok" else throw "role module missing"
    );

    role-modules-structure = builtins.toFile "role-modules-structure-ok" (
      let
        assertList = v: if builtins.isList v then true else throw "role module imports not a list";
      in
        builtins.seq (
          assertList config.flake.nixosModules.roles.dev.imports
          && assertList config.flake.nixosModules.roles.media.imports
          && assertList config.flake.nixosModules.roles.net.imports
        ) "ok"
    );

    helpers-exist = builtins.toFile "helpers-exist-ok" (
      if (config.flake.lib.nixos ? getApp)
        && (config.flake.lib.nixos ? getApps)
        && (config.flake.lib.nixos ? getAppOr)
        && (config.flake.lib.nixos ? hasApp)
      then "ok" else throw "missing one or more helper functions"
    );
  };
}
```

Note: Keep this assertion at flake level to avoid scope issues that arise when referencing top‑level module outputs from perSystem.

### Migration

- Before:
  - `with config.flake.nixosModules.apps; [ neovim httpie ]`
- After:
  - `let getApps = config.flake.lib.nixos.getApps; in getApps [ "neovim" "httpie" ]`
- One‑liner to find offenders for cleanup:
  - `rg -nU --pcre2 -S --glob 'modules/**/*.nix' -e '(?s)with\s*\(?\s*config\.flake\.nixosModules\.apps\s*\)?\s*;'`

### Naming Guidance (policy for new keys)

- App keys under `flake.nixosModules.apps.<name>` should be stable and consistently formatted.
- Prefer `camelCase` for multi‑word keys (e.g., `vscodeFhs`, `wireguardTools`).
- Permit underscores where they reflect upstream/version delineation (e.g., `nodejs_22`).
- Discourage hyphens to avoid quoting friction in attr paths.
- Acronyms lowercased (e.g., `httpClient`, `vpnTools`) unless repo convention dictates otherwise.
- Examples: `vpnTools`, `httpClient`, `wireguardTools`, `nodejs_22`.
- Migrations of existing keys are out of scope for rev 3.6; policy applies going forward.
- Avoid collisions with top‑level aggregator namespaces (e.g., `roles`, `apps`, `meta`, `ci`, `base`).

### Style Note on `with` (soft guidance)

- Beyond the hard guard on `with … nixosModules.apps`, avoid using `with` over broad scopes in role modules where practical. Prefer explicit references for greppability and clarity; helpers (`getApp`, `getApps`, `getAppOr`) are the primary composition path.

4. Validation

- Run `nix flake check --accept-flake-config`.
- Run `nix develop -c pre-commit run --all-files` and `nix fmt`.
- Ensure `generation-manager score` ≥ 90/90.

## Acceptance Criteria (approval is binary)

1. `modules/meta/flake-output.nix` exports an option `flake.lib.nixos` (`attrsOf anything`, default `{}`) and documents its purpose.
2. `modules/meta/nixos-app-helpers.nix` is present and exports `flake.lib.nixos.{hasApp,getApp,getApps,getAppOr}` with the error message `Unknown NixOS app '<name>'` (or equivalent) for missing apps.
3. `modules/roles/{dev,media,net}.nix` import app modules exclusively through `config.flake.lib.nixos.getApps`/`getApp`, retain alias modules, and include brief comments for non-app imports when applicable.
4. `modules/meta/git-hooks.nix` registers the `forbid-with-apps-in-roles` pre-commit hook using the PCRE2 ripgrep command shown above; the hook is enabled by default.
5. CI (e.g., via `modules/meta/ci.nix`) asserts helper availability and role alias structure during automated checks without forcing evaluations with `mkForce`.
6. Documentation (`docs/DENDRITIC_PATTERN_REFERENCE.md`, `docs/MODULE_STRUCTURE_GUIDE.md`, `modules/readme.nix`, and this RFC) references the helper API and removes claims that the helpers already existed.
7. The repository is free of `with config.flake.nixosModules.apps` occurrences (verified with `rg -nU --pcre2 -S --glob 'modules/**/*.nix' -e '(?s)with\s*\(?\s*config\.flake\.nixosModules\.apps\s*\)?\s*;'`).
8. The helpers and roles do not reference `inputs.self` or `self.nixosModules` directly (verified with `rg -nU --pcre2 -S --glob 'modules/roles/**/*.nix' --glob 'modules/meta/nixos-app-helpers.nix' -e '\\binputs\\s*\\.\\s*self\\s*\\.\\s*nixosModules\\b' -e '\\bself\\s*\\.\\s*nixosModules\\b'`).
9. Validation evidence accompanies the acceptance PR: `nix fmt`, `nix develop -c pre-commit run --all-files`, `generation-manager score` (≥ 90/90), and `nix flake check --accept-flake-config` all succeed with the new guardrails enabled.

## Rollback / Allowlist / Out of Scope

- Registry inversion is explicitly out of scope for rev 3.6.
- Allowlists are not supported in rev 3.6 (KISS + strictness). Emergency `--no-verify` usage is discouraged and not part of policy (last‑resort local escape hatch only).

## Risks and Mitigations

- Typos in app names: `getApp`/`getApps` throw with a clear message; caught at evaluation time.
- Hidden consumers: We do not change where apps are exported; no compatibility bridge needed.

## Test Plan

- Flake evaluation: `nix flake show --accept-flake-config` lists `apps`, `roles`, and `role-*` modules.
- Full checks: `nix flake check --accept-flake-config` passes.
- CI: `nix develop -c pre-commit run --all-files` passes (including the hook guard). Dev shell MUST include `pre-commit` and `rg`.
- Discoverability: use a REPL or a small eval helper to print `lib.attrNames config.flake.nixosModules.apps` to help reviewers spot typos.

## Sign‑off

- Owner: Author
- Approver(s): Reviewer, Dendrite
- Date: 2025-09-13

## Conclusion

This RFC delivers a complete, type‑safe approach to role composition using explicit helpers, stable role aliases, and CI guardrails. It avoids self recursion and aggregator brittleness without adding a new registry, aligns with Nix best practices, and provides a clear Acceptance Criteria and Test Plan for approval.
