# RFC-001: App Module Composition (Helpers-First, Type-Correct)

## Summary

- Adopt a complete, self-contained approach for composing roles from per‑app modules using explicit helpers (`getApp`, `getApps`) and robust lookups.
- Keep per‑app modules defined under `flake.nixosModules.apps.<name>` (no new registry required).
- Provide stable role aliases (`role-dev`, `role-media`, `role-net`) for host imports and consistency.
- Include type-correction notes and a clear, immediate implementation with CI guardrails.

## Motivation

Using `with config.flake.nixosModules.apps; [ … ]` inside roles is brittle with the flake‑parts aggregator because nested namespaces like `apps` are aggregated as modules with `imports`. We observed undefined symbol errors and ordering issues. We want roles to remain modular and composable while avoiding reliance on aggregator internals.

Additionally, deriving a stable view by reading `inputs.self.nixosModules.apps` while computing outputs risks self recursion and violates Nix best practices. This RFC explicitly avoids `self` output peeking.

## Goals

- Ensure role composition is robust and independent of aggregator internals by using explicit lookups and helpers.
- Keep the per‑app module pattern self-contained under `flake.nixosModules.apps.<name>`.
- Provide consistent role aliases: `role-dev`, `role-media`, `role-net`.
- Document type‑correct behavior and guard against regressions via CI.

## Current State

- Roles/dev, roles/media, and roles/net compose apps via guarded lookups using `lib.hasAttrByPath`/`lib.getAttrFromPath`; stable aliases `role-dev`, `role-media`, and `role-net` are defined.
- The system76 host imports these aliases alongside other modules.
- Home Manager role glue already uses guarded lookups for HM apps and composes from role data under `flake.lib.homeManager.roles`.

## Critical Analysis and Type Notes

- Aggregator shape: flake‑parts declares `flake.nixosModules` as `lazyAttrsOf deferredModule`. Nested keys like `apps.<name>` are implemented via aggregation into a module with `imports`. Therefore, `with` is fragile; explicit lookup is robust and type‑correct for our aggregator.
- Self recursion: Avoid reading from `inputs.self.*` when constructing outputs. This RFC does not use `self` output peeking.
- Type correctness: Under our current aggregator, assigning `apps = { imports = [ ... ]; }` is valid (apps is itself a deferred module). If we ever switch to a nested typed schema where `apps :: attrsOf deferredModule`, then helpers continue to work unchanged, but assigning `apps = { imports = ...; }` would no longer be valid. This RFC stays type‑correct in both cases because it does not depend on assigning to `apps` wholesale.

## Helpers (Complete Solution)

File to add: `modules/meta/nixos-app-helpers.nix`

- Define thin helpers that operate on the current aggregator (no new registry):

```nix
{ lib, config, ... }:
{
  flake.lib.nixos = {
    getApp = name:
      if lib.hasAttrByPath [ "apps" name ] config.flake.nixosModules then
        lib.getAttrFromPath [ "apps" name ] config.flake.nixosModules
      else
        throw "Unknown NixOS app '${name}' referenced by roles";

    getApps = names: map (n: config.flake.lib.nixos.getApp n) names;
  };
}
```

## App Module Authoring Pattern

- Keep existing pattern: per‑app modules export to `flake.nixosModules.apps.<name> = …`.
- Continue using functions when `pkgs`/args are needed, per repo style.

## Roles Composition via Helpers

Example: `modules/roles/dev.nix`

```nix
{ config, ... }:
let
  getApps = config.flake.lib.nixos.getApps;
in
{
  flake.nixosModules.roles.dev.imports =
    getApps [
      "neovim" "vim" "cmake" "gcc" "gnumake" "pkg-config"
      "jq" "yq" "jnv" "tokei" "hyperfine" "git-filter-repo"
      "exiftool" "niv" "tealdeer" "httpie" "mitmproxy"
      "gdb" "valgrind" "strace" "ltrace" "vscodeFhs" "kiroFhs"
    ]
    ++ [ config.flake.nixosModules.dev.node ];

  flake.nixosModules."role-dev".imports = config.flake.nixosModules.roles.dev.imports;
}
```

Apply the same pattern to `roles/media.nix` and `roles/net.nix`, preserving non‑app imports (e.g., `"vpn-defaults"`, `media`).

### Stable Role Aliases

- `flake.nixosModules."role-dev".imports = config.flake.nixosModules.roles.dev.imports`
- `flake.nixosModules."role-media".imports = config.flake.nixosModules.roles.media.imports`
- `flake.nixosModules."role-net".imports = config.flake.nixosModules.roles.net.imports`

Hosts import alias modules for consistency:

```nix
(with config.flake.nixosModules; [
  workstation
  nvidia-gpu
]) ++ [
  config.flake.nixosModules."role-dev"
  config.flake.nixosModules."role-media"
  config.flake.nixosModules."role-net"
]
```

## Alternatives Considered

1. `with config.flake.nixosModules.apps`

- Fragile with aggregator flattening; replaced by explicit helpers.

2. Building an index from `inputs.self.nixosModules.apps`

- Risks self recursion; not acceptable.

3. Full registry inversion under `flake.lib.nixos.*`

- Unnecessary for current goals; helpers over the existing aggregator deliver the benefits with less disruption and remain type‑correct.

## Implementation Plan (Complete and Self-Contained)

1. Add helpers module

- Create `modules/meta/nixos-app-helpers.nix` defining `flake.lib.nixos.getApp/getApps` as above.

2. Enforce role composition pattern

- Refactor roles (dev/media/net) to use `getApps` (complete).
- Ensure aliases `role-dev`, `role-media`, `role-net` exist and hosts import them (complete for system76).

3. CI/Pre-commit guardrail

- Add a check to fail if `with\s+config\.flake\.nixosModules\.apps;` appears in `modules/roles/*.nix`.

### Regression Guard: Pre-commit Hook (Implementation)

- We enforce the ban on `with config.flake.nixosModules.apps;` inside role modules via a pre-commit hook integrated in `modules/meta/git-hooks.nix`.
- Hook details:

```nix
forbid-with-apps-in-roles =
  let
    checker = pkgs.writeShellApplication {
      name = "forbid-with-apps-in-roles";
      runtimeInputs = [ pkgs.ripgrep pkgs.gnugrep pkgs.coreutils ];
      text = ''
        set -euo pipefail
        cd "$(git rev-parse --show-toplevel)"
        PATTERN='with\s+config\.flake\.nixosModules\.apps\s*;'
        if command -v rg >/dev/null 2>&1; then
          if rg -n -S -e "$PATTERN" --glob '*.nix' modules/roles >/dev/null; then
            echo "✗ Forbidden usage found in modules/roles/*.nix" >&2
            echo "  Use helpers: config.flake.lib.nixos.getApp/getApps (see docs/RFC-001.md)." >&2
            rg -n -S -e "$PATTERN" --glob '*.nix' modules/roles || true
            exit 1
          fi
        else
          if grep -R -n -E "$PATTERN" --include='*.nix' modules/roles >/dev/null 2>&1; then
            echo "✗ Forbidden usage found in modules/roles/*.nix" >&2
            echo "  Use helpers: config.flake.lib.nixos.getApp/getApps (see docs/RFC-001.md)." >&2
            grep -R -n -E "$PATTERN" --include='*.nix' modules/roles || true
            exit 1
          fi
        fi
      '';
    };
  in
  {
    enable = true;
    name = "forbid-with-apps-in-roles";
    entry = lib.getExe checker;
    pass_filenames = false;
    always_run = true;
    verbose = true;
  };
```

- Scope: Only `modules/roles/*.nix` are checked; other namespaces (e.g., `dev`, `lang`) are not restricted by this rule.
- Guidance: Replace the forbidden construct with `config.flake.lib.nixos.getApps [ "app1" "app2" ]` (or `map getApp …`).

4. Validation

- Run `nix flake check --accept-flake-config`.
- Run `nix develop -c pre-commit run --all-files` and `nix fmt`.
- Ensure `generation-manager score` ≥ 90/90.

## Risks and Mitigations

- Typos in app names: `getApp`/`getApps` throw with a clear message; caught at evaluation time.
- Hidden consumers: We do not change where apps are exported; no compatibility bridge needed.

## Validation & Testing

- Flake evaluation: `nix flake show --accept-flake-config` lists `apps`, `roles`, and `role-*` modules.
- Full checks: `nix flake check --accept-flake-config` passes.
- CI: Pre‑commit hooks (format/lint) pass; `generation-manager score` ≥ 90/90.

## Conclusion

This RFC delivers a complete solution now: roles compose from per‑app modules via explicit, type‑correct helpers; stable role aliases unify host imports; CI prevents regressions. It avoids self recursion and aggregator brittleness without adding a new registry, aligning with Nix best practices and the repository’s current architecture.
