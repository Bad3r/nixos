# RFC-001 (rev 3.6): App Module Composition (Helpers-First, Type-Correct)

## Summary

- Adopt a complete, self-contained approach for composing roles from per‑app modules using explicit helpers (`getApp`, `getApps`) and robust lookups.
- Keep per‑app modules defined under `flake.nixosModules.apps.<name>` (no new registry required).
- Provide stable role aliases (`role-dev`, `role-media`, `role-net`) for host imports and consistency.
- Include type-correction notes and a clear, immediate implementation with CI guardrails.

Process guard: This RFC is documentation-only. No code will be implemented until this RFC is explicitly approved. Any “prior work” mentioned is background and not in scope.

## Motivation

Using `with config.flake.nixosModules.apps; [ … ]` inside roles is brittle with the flake‑parts aggregator because nested namespaces like `apps` are aggregated as modules with `imports`. We observed undefined symbol errors and ordering issues. We want roles to remain modular and composable while avoiding reliance on aggregator internals.

Additionally, deriving a stable view by reading `inputs.self.nixosModules.apps` while computing outputs risks self recursion and violates Nix best practices. This RFC explicitly avoids `self` output peeking.

## Goals

- Ensure role composition is robust and independent of aggregator internals by using explicit lookups and helpers.
- Keep the per‑app module pattern self-contained under `flake.nixosModules.apps.<name>`.
- Provide consistent role aliases: `role-dev`, `role-media`, `role-net`.
- Document type‑correct behavior and guard against regressions via CI.

## Current State

- Roles/dev, roles/media, and roles/net compose apps via guarded lookups using `lib.hasAttrByPath`/`lib.getAttrFromPath`; stable aliases `role-dev`, `role-media`, and `role-net` are defined.
- The system76 host imports these aliases alongside other modules.
- Home Manager role glue already uses guarded lookups for HM apps and composes from role data under `flake.lib.homeManager.roles`.

## Critical Analysis and Type Notes

- Aggregator typing (repo reality):
  - Home Manager: We declare a nested typed schema under `flake.homeManagerModules` (with `apps :: attrsOf deferredModule`).
  - NixOS: We rely on flake‑parts’ top‑level `flake.nixosModules :: lazyAttrsOf deferredModule` (no nested typed `apps/roles` options declared in this repo).
  - Consequence: Lexical `with config.flake.nixosModules.apps;` is fragile; explicit helper lookups remain robust across both shapes.
- Self recursion: Avoid reading from `inputs.self.*` when constructing outputs. This RFC does not use `self` output peeking.
- Type correctness: This RFC does not assign to `apps` wholesale and relies only on explicit lookups via helpers. The approach is type‑safe in both aggregator shapes. Wholesale assignment to `apps` is not used and not recommended.

## Helpers (Complete Solution)

File to add: `modules/meta/nixos-app-helpers.nix`

- Define configuration‑aware helpers over the current aggregator (no new registry):

```nix
{ lib, config, ... }:
{
  flake.lib.nixos = {
    hasApp = name: lib.hasAttrByPath [ "apps" name ] config.flake.nixosModules;

    getApp = name:
      if lib.hasAttrByPath [ "apps" name ] config.flake.nixosModules then
        lib.getAttrFromPath [ "apps" name ] config.flake.nixosModules
      else
        throw "Unknown NixOS app '${name}'";

    getApps = names: map (n: config.flake.lib.nixos.getApp n) names;

    getAppOr = name: default:
      if lib.hasAttrByPath [ "apps" name ] config.flake.nixosModules
      then lib.getAttrFromPath [ "apps" name ] config.flake.nixosModules
      else default;
  };
}
```

Helper availability: Since Nix modules merge options lazily, these helpers are available to roles at evaluation time regardless of import order.

Helpers contract: Helpers are pure/idempotent readers over `config` (functions + small metadata only) and MUST NOT perform heavy evaluation or side effects.

Helpers root option: Declare a helpers namespace to avoid unknown‑option warnings. Add in a meta module (MUST be declared upon implementation approval):

```nix
options.flake.lib.nixos = lib.mkOption {
  type = lib.types.attrsOf lib.types.anything;
  default = {};
  description = "Helper functions for NixOS app composition";
};
```

## App Module Authoring Pattern

- Keep existing pattern: per‑app modules export to `flake.nixosModules.apps.<name> = …`.
- Continue using functions when `pkgs`/args are needed, per repo style.

## Roles Composition via Helpers

Example: `modules/roles/dev.nix`

```nix
{ config, ... }:
let
  getApps = config.flake.lib.nixos.getApps;
in
{
  flake.nixosModules.roles.dev.imports =
    getApps [
      "neovim" "vim" "cmake" "gcc" "gnumake" "pkg-config"
      "jq" "yq" "jnv" "tokei" "hyperfine" "git-filter-repo"
      "exiftool" "niv" "tealdeer" "httpie" "mitmproxy"
      "gdb" "valgrind" "strace" "ltrace" "vscodeFhs" "kiroFhs"
    ]
    ++ [ config.flake.nixosModules.dev.node ];

  flake.nixosModules."role-dev".imports = config.flake.nixosModules.roles.dev.imports;
}
```

Apply the same pattern to `roles/media.nix` and `roles/net.nix`, preserving non‑app imports (e.g., `"vpn-defaults"`, `media`).

Note on Node bundle (decision): Adopt the `config.flake.nixosModules.dev.node` bundle as the single source of truth in `roles/dev.nix` (to be executed upon approval). Add a short comment enumerating the bundle contents to guide future edits. (Migrations of existing code are out of scope for rev 3.6.)

### Examples (copy‑pasteable)

Minimal app authoring and role composition:

```nix
# modules/apps/neovim.nix
{ config, ... }:
{
  flake.nixosModules.apps.neovim = { pkgs, ... }: {
    environment.systemPackages = [ pkgs.neovim ];
  };
}

# modules/roles/dev.nix
{ config, ... }:
let
  getApps = config.flake.lib.nixos.getApps;
in
{
  flake.nixosModules.roles.dev.imports = getApps [ "neovim" ];
  flake.nixosModules."role-dev".imports = config.flake.nixosModules.roles.dev.imports;
}
```

### Stable Role Aliases

- `flake.nixosModules."role-dev".imports = config.flake.nixosModules.roles.dev.imports`
- `flake.nixosModules."role-media".imports = config.flake.nixosModules.roles.media.imports`
- `flake.nixosModules."role-net".imports = config.flake.nixosModules.roles.net.imports`

Hosts import alias modules for consistency:

```nix
(with config.flake.nixosModules; [
  workstation
  nvidia-gpu
]) ++ [
  config.flake.nixosModules."role-dev"
  config.flake.nixosModules."role-media"
  config.flake.nixosModules."role-net"
]
```

## Alternatives Considered

1. `with config.flake.nixosModules.apps`

- Fragile with aggregator flattening; replaced by explicit helpers.

2. Building an index from `inputs.self.nixosModules.apps`

- Risks self recursion; not acceptable.

3. Full registry inversion under `flake.lib.nixos.*`

- Unnecessary for current goals; helpers over the existing aggregator deliver the benefits with less disruption and remain type‑correct.

## Implementation Plan (to be executed upon approval)

1. Add helpers module

- Create `modules/meta/nixos-app-helpers.nix` defining `flake.lib.nixos.getApp/getApps` as above.

2. Enforce role composition pattern

- Refactor roles (dev/media/net) to use `getApps`.
- Ensure aliases `role-dev`, `role-media`, `role-net` exist and hosts import them.

3. CI/Pre-commit guardrail

- Add a check to fail if `with\s+config\.flake\.nixosModules\.apps;` appears in `modules/roles/**/*.nix` (multiline‑safe).

### Regression Guard: Pre-commit Hook (Implementation)

- We enforce the ban on `with config.flake.nixosModules.apps;` inside role modules via a pre-commit hook integrated in `modules/meta/git-hooks.nix`.
- Environment: relies on `pkgs.ripgrep` with PCRE2 enabled; retains a `grep` fallback for environments without `rg` (documented as less precise).
- Hook details:

```nix
forbid-with-apps-in-roles =
  let
    checker = pkgs.writeShellApplication {
      name = "forbid-with-apps-in-roles";
      runtimeInputs = [ pkgs.ripgrep pkgs.gnugrep pkgs.coreutils ];
      text = ''
        set -euo pipefail
        cd "$(git rev-parse --show-toplevel)"
        if rg -nU --pcre2 --glob 'modules/roles/**/*.nix' -e '(?s)with\s*\(?\s*config\.flake\.nixosModules\.apps\s*\)?\s*;' >/dev/null; then
          echo "✗ Forbidden usage found in modules/roles/**/*.nix" >&2
          echo "  Use helpers: config.flake.lib.nixos.getApp/getApps (see docs/RFC-001.md)." >&2
          rg -nU --pcre2 --glob 'modules/roles/**/*.nix' -e '(?s)with\s*\(?\s*config\.flake\.nixosModules\.apps\s*\)?\s*;' || true
          exit 1
        fi
      '';
    };
  in
  {
    enable = true;
    name = "forbid-with-apps-in-roles";
    entry = lib.getExe checker;
    pass_filenames = false;
    always_run = true;
    verbose = true;
  };
```

- Scope: Only `modules/roles/**/*.nix` are checked; other namespaces (e.g., `dev`, `lang`) are not restricted by this rule.
- Guidance: Replace the forbidden construct with `config.flake.lib.nixos.getApps [ "app1" "app2" ]` (or `map getApp …`).
- CI tool: CI MUST use ripgrep with PCRE2; grep fallback is local only and less precise. Dev shell MUST include `pre-commit` and `rg` so `nix develop -c pre-commit run --all-files` performs the guard end‑to‑end.
Note: The PCRE2 guard may match commented or quoted code in rare cases; this is acceptable noise to triage manually given the narrow scope.

### Cheap Smoke Check (Evaluation‑Only)

- Add flake‑level checks (placed in a meta CI module such as `modules/meta/ci.nix`) that assert:
  - Each role alias ("role-dev", "role-media", "role-net") exists as an attr.
  - Each alias’ `imports` evaluates to a list (no builds).
  - Helpers exist under `config.flake.lib.nixos` using attribute tests (e.g., `(config.flake.lib.nixos ? getApp) && (config.flake.lib.nixos ? getApps) && (config.flake.lib.nixos ? getAppOr) && (config.flake.lib.nixos ? hasApp)`).

Example (flake‑level module):

```nix
# modules/meta/ci.nix
{ lib, config, ... }:
{
  checks = {
    role-aliases-exist = builtins.toFile "role-aliases-exist-ok" (
      if (config.flake.nixosModules ? "role-dev") && (config.flake.nixosModules ? "role-media") && (config.flake.nixosModules ? "role-net")
      then "ok" else throw "role-* alias missing"
    );

    role-aliases-structure = builtins.toFile "role-aliases-structure-ok" (
      let
        assertList = v: if builtins.isList v then true else throw "role alias imports not a list";
      in
        builtins.seq (
          assertList config.flake.nixosModules.roles.dev.imports
          && assertList config.flake.nixosModules.roles.media.imports
          && assertList config.flake.nixosModules.roles.net.imports
        ) "ok"
    );

    helpers-exist = builtins.toFile "helpers-exist-ok" (
      if (config.flake.lib.nixos ? getApp)
        && (config.flake.lib.nixos ? getApps)
        && (config.flake.lib.nixos ? getAppOr)
        && (config.flake.lib.nixos ? hasApp)
      then "ok" else throw "missing one or more helper functions"
    );
  };
}
```

Note: Keep this assertion at flake level to avoid scope issues that arise when referencing top‑level module outputs from perSystem.

### Migration

- Before:
  - `with config.flake.nixosModules.apps; [ neovim httpie ]`
- After:
  - `let getApps = config.flake.lib.nixos.getApps; in getApps [ "neovim" "httpie" ]`
- One‑liner to find offenders for cleanup:
  - `rg -nU --pcre2 -S --glob 'modules/**/*.nix' -e '(?s)with\s*\(?\s*config\.flake\.nixosModules\.apps\s*\)?\s*;'`

### Naming Guidance (policy for new keys)

- App keys under `flake.nixosModules.apps.<name>` should be stable and consistently formatted.
- Prefer `camelCase` for multi‑word keys (e.g., `vscodeFhs`, `wireguardTools`).
- Permit underscores where they reflect upstream/version delineation (e.g., `nodejs_22`).
- Discourage hyphens to avoid quoting friction in attr paths.
- Acronyms lowercased (e.g., `httpClient`, `vpnTools`) unless repo convention dictates otherwise.
- Examples: `vpnTools`, `httpClient`, `wireguardTools`, `nodejs_22`.
- Migrations of existing keys are out of scope for rev 3.6; policy applies going forward.
- Avoid collisions with top‑level aggregator namespaces (e.g., `roles`, `apps`, `meta`, `ci`, `base`).

### Style Note on `with` (soft guidance)

- Beyond the hard guard on `with … nixosModules.apps`, avoid using `with` over broad scopes in role modules where practical. Prefer explicit references for greppability and clarity; helpers (`getApp`, `getApps`, `getAppOr`) are the primary composition path.

4. Validation

- Run `nix flake check --accept-flake-config`.
- Run `nix develop -c pre-commit run --all-files` and `nix fmt`.
- Ensure `generation-manager score` ≥ 90/90.

## Acceptance Criteria (approval is binary)

- Helpers root option is declared in `modules/meta/flake-output.nix` (section “Helpers root option”).
- Helpers module location specified as `modules/meta/nixos-app-helpers.nix` and documents exported functions `config.flake.lib.nixos.{hasApp,getApp,getApps,getAppOr}`.
- Pre‑commit hook named `forbid-with-apps-in-roles` resides in `modules/meta/git-hooks.nix` and uses exactly:
  `rg -nU --pcre2 --glob 'modules/roles/**/*.nix' -e '(?s)with\s*\(?\s*config\.flake\.nixosModules\.apps\s*\)?\s*;'`.
- Smoke checks described at flake‑level (e.g., `modules/meta/ci.nix`) include: (a) role alias attrs exist; (b) each alias’ `imports` evaluates to a list (no builds); and (c) a helpers‑exist assertion under `config.flake.lib.nixos` using attribute tests for `hasApp`, `getApp`, `getApps`, and `getAppOr`.
- Smoke checks MUST NOT rely on `mkForce` unless justified inline with a one‑line comment.
- Node bundle decision documented: `roles/dev.nix` adopts `config.flake.nixosModules.dev.node` as the single source of truth and includes a short comment listing bundle contents.
- Docs updated: README and Dendritic docs reflect the aggregator distinction (HM nested typed; NixOS flake‑parts top‑level) and the naming policy. Specifically update:
  - `README.md` (roles section link + aggregator note)
  - `docs/MODULE_STRUCTURE_GUIDE.md` (aggregator note + helper usage)
  - `docs/DENDRITIC_PATTERN_REFERENCE.md` (aggregator distinction)
- CI MUST use ripgrep with PCRE2; grep fallback is for local only. Dev shell MUST include `pre-commit` and `rg` so local checks run out of the box.
- One‑time cleanliness scan: at approval time, repo MUST be free of any `with config.flake.nixosModules.apps;` occurrences.
- One‑time cleanliness scan literal command is documented and PASSED at approval time:
  - `rg -nU --pcre2 -S --glob 'modules/**/*.nix' -e '(?s)with\s*\(?\s*config\.flake\.nixosModules\.apps\s*\)?\s*;'`
- Purity guard: No references to `self.nixosModules*` or `inputs.self.nixosModules*` exist in roles or the helpers module, verified with:
  - `rg -nU --pcre2 -S --glob 'modules/roles/**/*.nix' --glob 'modules/meta/nixos-app-helpers.nix' -e '\binputs\s*\.\s*self\s*\.\s*nixosModules\b' -e '\bself\s*\.\s*nixosModules\b'`
- Flake retains `nixConfig.abort-on-warn = true` (zero‑warning policy enforced).
- Meta‑layer type guard: a simple assertion MUST exist to ensure `flake.nixosModules.apps` is an attrset, with an actionable error if not.
- Validation plan included: `nix flake check`, pre‑commit hooks passing, and `generation-manager` score target satisfied.
- Process guard included: “no code before approval” stated in RFC preface.

## Rollback / Allowlist / Out of Scope

- Registry inversion is explicitly out of scope for rev 3.6.
- Allowlists are not supported in rev 3.6 (KISS + strictness). Emergency `--no-verify` usage is discouraged and not part of policy (last‑resort local escape hatch only).

## Risks and Mitigations

- Typos in app names: `getApp`/`getApps` throw with a clear message; caught at evaluation time.
- Hidden consumers: We do not change where apps are exported; no compatibility bridge needed.

## Test Plan

- Flake evaluation: `nix flake show --accept-flake-config` lists `apps`, `roles`, and `role-*` modules.
- Full checks: `nix flake check --accept-flake-config` passes.
- CI: `nix develop -c pre-commit run --all-files` passes (including the hook guard). Dev shell MUST include `pre-commit` and `rg`.
- Discoverability: use a REPL or a small eval helper to print `lib.attrNames config.flake.nixosModules.apps` to help reviewers spot typos.

## Sign‑off

- Owner: Author
- Approver(s): Reviewer, Dendrite
- Date: 2025-09-13

## Conclusion

This RFC delivers a complete, type‑safe approach to role composition using explicit helpers, stable role aliases, and CI guardrails. It avoids self recursion and aggregator brittleness without adding a new registry, aligns with Nix best practices, and provides a clear Acceptance Criteria and Test Plan for approval.
